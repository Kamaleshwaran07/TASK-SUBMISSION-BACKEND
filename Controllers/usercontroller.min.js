import User from '../Models/user.model.min.js'
import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';
import dotenv from 'dotenv';
import nodemailer from 'nodemailer'
import crypto from 'crypto'
import { log } from 'console';
import shortid from 'shortid';
import Task from '../Models/task.model.min.js';


dotenv.config();

function generateShortUrl() {
    return shortid.generate();
}

const userContoller = {
    //Home Page
    homePage: async (req, res) => {
        try {
            res.status(200).send({ message: "Welcome to Home page of Task submission" });
        } catch (error) {
            res.status(500).json({ message: error.message })
        }
    },

    signup: async (req, res) => {
        try {
            // get the user inputs

            const { username, password, name, role } = req.body;
            const user = await User.findOne({ username });
            //Checking if the user exists
            if (user) {
                return res.status(400).json({ message: "This e-mail has already have an account. Login to continue!" })
            }
            //Hashing the password
            const passwordHash = await bcrypt.hash(password, 10);
            // Create a new password
            const newUser = new User({
                username, passwordHash, name, role
            });
            const savedUser = await newUser.save()
            res.status(200).json({
                message: "Registered successfully", user: {
                    username: savedUser.username, name: savedUser.name, role:savedUser.role, activationStatus: savedUser.activationStatus
                }
            })
            const userId = savedUser._id;
            console.log(userId + " is the id");
            const token = crypto.randomBytes(10).toString('hex')
            // save the random string in database
            console.log(token);
            savedUser.token = token;
            await savedUser.save()

        } catch (error) {
            res.status(400).json({ message: "Error creating a user" })
        }

    },
    
    signin: async (req, res) => {
        try {
            // Get the data from the user
            const { username, password } = req.body;

            const user = await User.findOne({ username });
            // Check the user available in the database
            if (!user) {
                return res.status(400).json({ message: "User not found" })
            }
            // Checking for password match
            const passwordMatch = await bcrypt.compare(password, user.passwordHash)

            if (!passwordMatch) {
                return res.status(401).json({ message: "Password is not right Check again" })
            }
           
            const token = jwt.sign({
                username: user.username,
                id: user._id,
                name: user.name
            }, process.env.JWT_secret)
            res.cookie('token', token, {
                httpOnly: true,
                sameSite: 'strict',
                expires: new Date(Date.now() + 24 * 60 * 60 * 1000),
                secure: true,
            })
            res.json({ message: "Logged in Successfully",user, token })


        } catch (error) {
            res.status(500).json({ message: 'Server Error' })
        }
    },
    getUser: async (req, res) => {
        try {
            // getting the username
            const { username } = req.body;
            // Check the user available in the database

            const user = await User.findOne({ username });
            if (!user) {
                return res.status(400).json({ message: "No such user exists" })
            }
            res.status(200).json({ user, message: "Username verified! Enter your new password" })
        } catch (error) {
            console.log(error);
        }
    },
    forgotPassword: async (req, res, next) => {
        try {
            // getting the username

            const { username } = req.body;
            const user = await User.findOne({ username })
            // const token = await User.findOne({token})

            if (!user) {
                return res.status(400).json({ message: "No such user exists" })
            }
            else {
                // generate a random string

                const token = crypto.randomBytes(10).toString('hex')
                // save the random string in database
                console.log(token);
                user.token = token;
                await user.save()
                // Nodemailer
                const transporter = nodemailer.createTransport({
                    service: 'gmail',
                    auth: {
                        user: 'kamaleshwaranvlup@gmail.com',
                        pass: process.env.PASSWORD
                    }
                });

                // Email parameters
                const option = {
                    from: 'kamaleshwaranvlup@gmail.com',
                    to: username,
                    subject: 'Passwordreset',
                    text: `Your Url for resetting the password, 
                    ${process.env.baseurl}resetpassword/${user._id}/${user.token}`
                };

                // Sending the mail
                transporter.sendMail(option, function (error, info) {
                    if (error) {
                        res.status(400).json({ message: "Error sending the mail" })
                    }
                    else {
                        res.status(200).json({ message: 'Email has been sent. Check your inbox. Go to Login page to log back in', info })
                    }
                })
            }

        } catch (error) {
            console.error('Error in forgotPassword controller:', error);
            res.status(500).json({ message: 'Internal Server Error' });
        }
    },
    resetPassword: async (req, res, next) => {
        try {
            // Getting the userId and random string from the url as params
            const { userId, token } = req.params;
            const { password } = req.body;
            // console.log( password);
            // Checking both userId and token to find the user
            const user = await User.findOne({ _id: userId, token })
            console.log(user);
            // const token = await User.findOne({token})
            if (!user) {
                return res.status(400).json({ message: "No such user exists" })
            }

            // If userId and token matched, hash the new  password and update it in the database
            const passwordHash = await bcrypt.hash(password, 10);
            await User.findByIdAndUpdate(user._id, { passwordHash: passwordHash })
            await User.findByIdAndUpdate(user._id, { token: null })

            res.status(200).json({ message: 'Password has been reset successfully. Login again to continue' })

        } catch (error) {
            console.error('Error in sending the url', error);

            res.status(500).json({ message: 'Internal Server Error' })
        }
    },
    posttaskurls: async (req, res) => {
        try {

            // getting the username
            const { userId } = req.params
            console.log(userId);
            // Check the user available in the database
            
            const user = await User.findOne({ _id: userId });
            if (!user) {
                return res.status(400).json({ message: "No such user exists" })
            }
            const {title, frontendcode, frontendurl, backendurl, backendcode } = req.body;
            const utaskId = crypto.randomBytes(3).toString('hex')
            // save the random string in database
            console.log(utaskId);
            const taskObject = { taskId: utaskId, title: title, frontEndCode: frontendcode, frontEndUrl: frontendurl, backEndUrl: backendurl, backEndCode: backendcode, user: userId, status:"Submitted", comment: null, score: null }
            const count = 0;
            user.task.push(taskObject)
            // console.log(userTaskUpdate);
            await user.save();
            const newTask = await new Task(taskObject)
            await newTask.save();
            res.status(200).json({message:"Task submitted successfully"})
        } catch (error) {
            console.log(error);
        }
    },
    getTaskUrls: async (req, res) => { 
        const { userId } = req.params;
        console.log(userId);
        try {
            const user = await User.findOne({ _id: userId });
            console.log(user);
            // console.log(role);
            if (!user) {
                res.status(400).json({ message: "User not found" })
                
            }
            //Conditional rendering of urls
            else if (user.role === "Mentor") {
                //Sending the urls of a single task
                const submittedTask = await Task.find({ status: "Submitted" }).select('-_id -status -__v ').limit(1)
                // console.log(submittedTask);
                return res.status(200).json({message:"Successfully fetched submitted tasks", submittedTask })
            }
            else(user.role === "Student")
                const comments = await Task.find({user: userId}).select('-_id -frontEndCode -frontEndUrl -backEndCode -backEndUrl -createdAt')
                console.log("comment", comments);
                
                    
                    res.status(200).json({comments, message:"Successfully fetched the score"})
                
            

        } catch (error) {
            res.status(500).json({message:"Internale Server Error"})
        }
    },

    postcommentscore: async (req, res) => {
        const {utaskId} = req.params;
        console.log(utaskId);
        if (!utaskId) {
            res.status(400).json({message:"Requested Task does not exist"})
        }
        try {
            const task = await Task.findOne({ taskId: utaskId }).populate('user')
            // console.log("Task", task);
            const { comment, score } = req.body;
            // console.log(comment, score);
            const taskId = task._id
            // console.log("TasK Id", taskId);
            const taskUpdate = await Task.findByIdAndUpdate(taskId, { comment: comment, score: score, status: "Evaluated" })
            console.log("Task Updated", taskUpdate);
            await taskUpdate.save()
            const userId = await task.user._id;
           
            // console.log("USer Id",userId);
            // const usertaskUpdate = await User.findByIdAndUpdate(userId, { comment: comment, score: score, status: "Evaluated" })
            const user = await User.findById(userId)
            const username = await user.name
            // console.log("UserData",user);
            // const commentobject = {comment: comment, score: score}
            // user.task.push(commentobject)
       
          //Looping through the tasks array to assign the comment and score
            const taskIndex = user.task.findIndex(task => task.taskId === taskId);
            console.log(taskIndex);
            if (taskIndex !== -1) {
                user.task({comment: comment, score: score, status:"Evaluated"})
            }
            // const usertaskUpdate = taskObject.
            // console.log("Task in user", usertaskUpdate);
            await user.save()
            // console.log(usertaskUpdate);
            res.status(200).json({message:"Task evaluated successfully", taskUpdate, username})
            
            
        } catch (error) {
            res.status(500).json({message:"Internal server Erroe"})
        }
    }
        
        

  

}

export default userContoller;